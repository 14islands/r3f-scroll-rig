{"version":3,"file":"powerups.modern.js","sources":["../powerups/WebGLText.tsx","../powerups/WebGLImage.tsx","../../node_modules/react-merge-refs/dist/react-merge-refs.esm.js","../powerups/ParallaxScrollScene.tsx","../powerups/StickyScrollScene.tsx","../../node_modules/@14islands/lerp/index.js","../../node_modules/lerp/index.js"],"sourcesContent":["import React, { useMemo, useEffect, ReactNode, MutableRefObject } from 'react'\nimport { Color, Material } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nimport { useScrollRig } from '@14islands/r3f-scroll-rig'\n\n/**\n * Returns a WebGL Troika text mesh styled as the source DOM element\n */\n\ninterface WebGLTextProps {\n  el: MutableRefObject<HTMLElement>\n  children?: ReactNode\n  material?: Material\n  scale?: any\n  font?: string\n  fontOffsetY?: number\n  fontOffsetX?: number\n  overrideEmissive?: boolean\n  color?: string\n}\n\nexport const WebGLText = ({\n  el,\n  children,\n  material,\n  scale,\n  font,\n  fontOffsetY = 0,\n  fontOffsetX = 0,\n  overrideEmissive = false,\n  color,\n  ...props\n}: WebGLTextProps) => {\n  const { size } = useThree()\n  const { scaleMultiplier } = useScrollRig()\n\n  const { textColor, fontSize, textAlign, lineHeight, letterSpacing } = useMemo(() => {\n    if (!el.current) return {}\n    const cs = window.getComputedStyle(el.current)\n\n    // font size relative letter spacing\n    const letterSpacing = (parseFloat(cs.letterSpacing) || 0) / parseFloat(cs.fontSize)\n    const lineHeight = (parseFloat(cs.lineHeight) || 0) / parseFloat(cs.fontSize)\n    const textColor = new Color(color || cs.color).convertSRGBToLinear()\n\n    return {\n      letterSpacing,\n      lineHeight,\n      textColor,\n      fontSize: parseFloat(cs.fontSize) * scaleMultiplier,\n      textAlign: cs.textAlign,\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [el, size, scale, color, scaleMultiplier]) // recalc on resize\n\n  useEffect(() => {\n    if (material && overrideEmissive) {\n      // @ts-ignore\n      material.emissive = color\n    }\n  }, [material, color, overrideEmissive])\n\n  let xOffset = 0\n  if (textAlign === 'left' || textAlign === 'start') {\n    xOffset = scale[0] * -0.5\n  } else if (textAlign === 'right' || textAlign === 'end') {\n    xOffset = scale[0] * 0.5\n  }\n\n  const yOffset = scale ? scale[1] * 0.5 : size.height * 0.5\n\n  return (\n    <Text\n      fontSize={fontSize}\n      maxWidth={scale ? scale[0] : size.width}\n      lineHeight={lineHeight}\n      // @ts-ignore\n      textAlign={textAlign}\n      letterSpacing={letterSpacing}\n      overflowWrap=\"break-word\"\n      font={font}\n      color={textColor}\n      // @ts-ignore\n      anchorX={textAlign}\n      anchorY=\"top\" // so text moves down if row breaks\n      // @ts-ignore\n      position={[xOffset + fontSize * fontOffsetX, yOffset + fontSize * fontOffsetY, 0]} // font specific\n      material={material}\n      {...props}\n    >\n      {children}\n    </Text>\n  )\n}\n","import React, { useRef, useMemo, useEffect, forwardRef, MutableRefObject, ForwardedRef } from 'react'\nimport { useScrollRig, useImageAsTexture, useScrollbar } from '@14islands/r3f-scroll-rig'\nimport { Color, Vector2, ShaderMaterial, Mesh, ShaderMaterialParameters } from 'three'\nimport { useFrame, useThree } from '@react-three/fiber'\n\nimport mergeRefs from 'react-merge-refs'\n\ninterface WebGLImageProps {\n  el: MutableRefObject<HTMLImageElement>\n  scale?: any\n  scrollState?: any\n  vertexShader?: string\n  fragmentShader?: string\n  invalidateFrameLoop: boolean\n  widthSegments?: number\n  heightSegments?: number\n}\n\nexport const WebGLImage = forwardRef(\n  (\n    {\n      el,\n      scale,\n      scrollState,\n      vertexShader,\n      fragmentShader,\n      invalidateFrameLoop = false,\n      widthSegments = 128,\n      heightSegments = 128,\n      ...props\n    }: WebGLImageProps,\n    ref: ForwardedRef<Mesh>\n  ) => {\n    const material = useRef<ShaderMaterial>(null!)\n    const mesh = useRef<Mesh>(null!)\n\n    const { invalidate, gl, size } = useThree()\n    const pixelRatio = useThree((s) => s.viewport.dpr)\n    const { scroll } = useScrollbar()\n    const { scaleMultiplier } = useScrollRig()\n\n    const texture = useImageAsTexture(el)\n\n    const uniforms = useMemo(() => {\n      return {\n        u_color: { value: new Color('black') },\n        u_time: { value: 0 },\n        u_pixelRatio: { value: pixelRatio },\n        u_progress: { value: 0 },\n        u_visibility: { value: 0 },\n        u_viewport: { value: 0 },\n        u_velocity: { value: 0 }, // scroll speed\n        u_res: { value: new Vector2() }, // screen dimensions\n        u_rect: { value: new Vector2() }, // DOM el dimensions\n        u_size: { value: new Vector2() }, // Texture dimensions\n        u_texture: { value: null },\n        u_loaded: { value: false },\n        u_scaleMultiplier: { value: scaleMultiplier },\n      }\n    }, [pixelRatio])\n\n    // Fade in when texture loaded\n    useEffect(() => {\n      if (!texture) return\n      if (!material.current) return\n      material.current.uniforms.u_texture.value = texture\n      material.current.uniforms.u_size.value.set(texture.image.width, texture.image.height)\n      material.current.uniforms.u_loaded.value = true\n    }, [texture, gl])\n\n    useEffect(() => {\n      if (!material.current) return\n      material.current.uniforms.u_res.value.set(size.width, size.height)\n      material.current.uniforms.u_rect.value.set(scale?.[0], scale?.[1])\n    }, [size, scale])\n\n    useFrame((_, delta) => {\n      if (!scrollState.inViewport || !mesh.current || !material.current) return\n\n      if (!material.current.uniforms.u_loaded.value) return\n\n      material.current.uniforms.u_time.value += delta\n\n      // update scale while animating too\n      material.current.uniforms.u_rect.value.set(mesh.current.scale.x, mesh.current.scale.y)\n\n      // px velocity\n      material.current.uniforms.u_velocity.value = scroll.velocity\n\n      // percent of total visible distance that was scrolled (0 = just outside bottom of screen, 1 = just outside top of screen)\n      material.current.uniforms.u_progress.value = scrollState.progress\n\n      // percent of item height in view\n      material.current.uniforms.u_visibility.value = scrollState.visibility\n      // percent of window height scrolled since visible\n      material.current.uniforms.u_viewport.value = scrollState.viewport\n\n      if (invalidateFrameLoop) invalidate()\n    })\n\n    const args = useMemo(\n      () => [\n        {\n          vertexShader,\n          fragmentShader,\n        },\n      ],\n      [vertexShader, fragmentShader]\n    )\n\n    return (\n      <>\n        <mesh ref={mergeRefs([mesh, ref])} {...props}>\n          <planeGeometry attach=\"geometry\" args={[1, 1, widthSegments, heightSegments]} />\n          <shaderMaterial\n            ref={material}\n            args={args as [ShaderMaterialParameters]}\n            transparent={true}\n            uniforms={uniforms}\n          />\n        </mesh>\n      </>\n    )\n  }\n)\n","function mergeRefs(refs) {\n  return function (value) {\n    refs.forEach(function (ref) {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport default mergeRefs;\n//# sourceMappingURL=react-merge-refs.esm.js.map\n","import React, { useRef } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\nimport { Mesh } from 'three'\n\n// Parallax group inside ScrollScene\nconst ParallaxGroup = ({ children, scrollState, parallax }: any) => {\n  const mesh = useRef<Mesh>(null!)\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  useFrame(() => {\n    if (!scrollState.inViewport) return\n    const parallaxProgress = scrollState.progress * 2 - 1\n    mesh.current.position.y = parallax * parallaxProgress * scaleMultiplier * size.height\n  })\n\n  return <mesh ref={mesh}>{children}</mesh>\n}\n\n/* Speed=1 is no parallax */\nexport const ParallaxScrollScene = ({ children, speed = 1, ...props }: any) => {\n  const extraMargin = 50 // add 50vh extra margin to avoid aggressive clipping\n  const parallaxAmount = speed - 1\n  return (\n    // @ts-ignore\n    <ScrollScene scissor={false} inViewportMargin={`${Math.max(0, 1 - 0.5) * 200 + extraMargin}%`} {...props}>\n      {(props) => (\n        <ParallaxGroup parallax={parallaxAmount} {...props}>\n          {children(props)}\n        </ParallaxGroup>\n      )}\n    </ScrollScene>\n  )\n}\n","import React, { useRef, useMemo } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { ScrollScene } from '@14islands/r3f-scroll-rig'\nimport { Group } from 'three'\n// @ts-ignore\nimport lerp from '@14islands/lerp'\n\n// Sticky mesh that covers full viewport size\nconst StickyChild = ({\n  children,\n  childTop,\n  childBottom,\n  scrollState,\n  parentScale,\n  childScale,\n  priority,\n  stickyLerp = 1.0,\n}: any) => {\n  const group = useRef<Group>(null!)\n  const size = useThree((s) => s.size)\n\n  useFrame((_, delta) => {\n    if (!scrollState.inViewport) return\n\n    const topOffset = childTop / size.height\n    const bottomOffset = childBottom / parentScale[1]\n\n    //  move to top of sticky area\n    const yTop = parentScale[1] * 0.5 - childScale[1] * 0.5\n    const yBottom = -parentScale[1] * 0.5 + childScale[1] * 0.5\n    const ySticky = -childTop + yTop - (scrollState.viewport - 1) * size.height\n\n    let y = group.current.position.y\n\n    // enter\n    if (scrollState.viewport + topOffset < 1) {\n      y = yTop\n    }\n    // sticky\n    else if (scrollState.visibility - bottomOffset < 1) {\n      y = ySticky\n    }\n    // exit\n    else {\n      y = yBottom\n    }\n\n    group.current.position.y = lerp(group.current.position.y, y, stickyLerp, delta)\n  }, priority) // must happen after ScrollScene's useFrame to be buttery\n\n  return <group ref={group}>{children}</group>\n}\n\nconst renderAsSticky = (children: any, size: any, childStyle: any, { stickyLerp, fillViewport }: any) => {\n  return ({ scale, ...props }: any) => {\n    // set child's scale to 100vh/100vw instead of the full DOM el\n    // the DOM el should be taller to indicate how far the scene stays sticky\n    let childScale = [parseFloat(childStyle.width), parseFloat(childStyle.height), 1]\n    let childTop = parseFloat(childStyle.top)\n    let childBottom = size.height - childTop - childScale[1]\n\n    if (fillViewport) {\n      childScale = [size.width, size.height, 1]\n      childTop = 0\n      childBottom = 0\n    }\n    return (\n      // @ts-ignore\n      <StickyChild\n        parentScale={scale}\n        childScale={childScale}\n        stickyLerp={stickyLerp}\n        childTop={childTop}\n        childBottom={childBottom}\n        {...props}\n      >\n        {children({ scale: childScale, ...props })}\n      </StickyChild>\n    )\n  }\n}\n\nexport const StickyScrollScene = ({ children, track, stickyLerp, fillViewport, ...props }: any) => {\n  const size = useThree((s) => s.size)\n\n  const internalRef = useRef(track.current)\n\n  // if tracked element is position:sticky, track the parent instead\n  // we want to track the progress of the entire sticky area\n  const childStyle = useMemo(() => {\n    const style = getComputedStyle(track.current)\n    if (style.position === 'sticky') {\n      internalRef.current = track.current.parentElement\n    } else {\n      console.error('StickyScrollScene: tracked element is not position:sticky')\n    }\n    return style\n  }, [track])\n\n  return (\n    <ScrollScene track={internalRef} {...props}>\n      {renderAsSticky(children, size, childStyle, { stickyLerp, fillViewport })}\n    </ScrollScene>\n  )\n}\n","const _lerp = require('lerp')\n\n/**\n * Drop-in replacement of standard lerp with optional frame delta and target fps\n * to maintain constant animation speed at various fps\n * \n * Based on http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * \n * @param {number} source Current value\n * @param {number} target Value to lerp towards\n * @param {number} rate Interpolation rate\n * @param {number} frameDelta Optional frame delta time in seconds. Should be 1/60 for a steady 60fps.\n * @param {number} targetFps Optional, target is 60 by default\n * @returns {number} interpolated value\n */\n\nfunction lerp(source, target, rate, frameDelta, targetFps = 60){\n  \n  // return normal lerp if no delta was passed\n  if (typeof frameDelta === 'undefined') {\n    return _lerp(source, target, rate)\n  }\n\n  const relativeDelta = frameDelta / (1 / targetFps)\n  const smoothing = 1 - rate\n  return _lerp(source, target, 1 - Math.pow(smoothing, relativeDelta));\n}\n\nmodule.exports = lerp","function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp"],"names":["WebGLText","_ref","el","children","material","scale","font","fontOffsetY","fontOffsetX","overrideEmissive","color","props","size","useThree","scaleMultiplier","useScrollRig","textColor","fontSize","textAlign","lineHeight","letterSpacing","useMemo","current","cs","window","getComputedStyle","parseFloat","convertSRGBToLinear","useEffect","emissive","xOffset","createElement","Text","_extends","maxWidth","width","overflowWrap","anchorX","anchorY","position","height","_excluded","WebGLImage","forwardRef","ref","scrollState","vertexShader","fragmentShader","invalidateFrameLoop","widthSegments","heightSegments","_objectWithoutPropertiesLoose","useRef","mesh","invalidate","gl","pixelRatio","s","viewport","dpr","scroll","useScrollbar","texture","useImageAsTexture","u_color","value","Color","u_time","u_pixelRatio","u_progress","u_visibility","u_viewport","u_velocity","u_res","Vector2","u_rect","u_size","u_texture","u_loaded","u_scaleMultiplier","uniforms","set","image","useFrame","_","delta","inViewport","x","y","velocity","progress","visibility","args","React","Fragment","refs","forEach","attach","transparent","ParallaxGroup","parallax","ParallaxScrollScene","speed","parallaxAmount","ScrollScene","scissor","inViewportMargin","Math","max","_excluded2","StickyChild","childTop","childBottom","parentScale","childScale","priority","stickyLerp","group","yTop","source","target","rate","frameDelta","targetFps","v1","t","pow","lerp","StickyScrollScene","_ref2","track","fillViewport","internalRef","childStyle","style","parentElement","console","error","top","renderAsSticky"],"mappings":"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"}