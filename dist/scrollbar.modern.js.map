{"version":3,"file":"scrollbar.modern.js","sources":["../src/config.ts","../src/store.ts","../src/scrollbar/useScrollbar.ts","../src/hooks/useIsomorphicLayoutEffect.ts","../src/scrollbar/SmoothScrollbar.tsx","../src/hooks/useWindowSize.ts","../src/utils/math.ts","../src/hooks/useTracker.ts"],"sourcesContent":["// Global config\nimport type { Scene, Camera, WebGLRenderer } from 'three'\n\ntype PreloadCallback = (gl: WebGLRenderer, scene: Scene, camera: Camera) => void\n\nexport const config = {\n  // Execution order for useFrames (highest = last render)\n  PRIORITY_PRELOAD: 0,\n  PRIORITY_SCISSORS: 1,\n  PRIORITY_VIEWPORTS: 1,\n  PRIORITY_GLOBAL: 1000,\n\n  DEFAULT_SCALE_MULTIPLIER: 1,\n\n  // Global rendering props\n  preloadQueue: [] as PreloadCallback[],\n}\n","import create from 'zustand'\nimport { config } from './config'\n\nimport { ScrollCallback } from './scrollbar/SmoothScrollbar.d'\n\ninterface ScrollRigStore {\n  debug: boolean\n  scaleMultiplier: number\n  globalRender: boolean\n  globalPriority: number\n  globalClearDepth: boolean\n  globalRenderQueue: false | any[]\n  clearGlobalRenderQueue: () => void\n  isCanvasAvailable: boolean\n  hasSmoothScrollbar: boolean\n  canvasChildren: Record<string, any | undefined>\n  updateCanvas: (key: string, newProps: any) => void\n  renderToCanvas: (key: string, mesh: any, props: any) => void\n  removeFromCanvas: (key: string, dispose: boolean) => void\n  pageReflow: number\n  requestReflow: () => void\n  scroll: {\n    y: number\n    x: number\n    limit: number\n    velocity: number\n    progress: number\n    direction: number\n    scrollDirection?: 'vertical' | 'horizontal'\n  }\n  scrollTo: (target: any) => void\n  onScroll: (cb: ScrollCallback) => () => void\n}\n\nconst useCanvasStore = create<ScrollRigStore>((set) => ({\n  // //////////////////////////////////////////////////////////////////////////\n  // GLOBAL ScrollRig STATE\n  // //////////////////////////////////////////////////////////////////////////\n  debug: false,\n  scaleMultiplier: config.DEFAULT_SCALE_MULTIPLIER,\n\n  globalRender: true,\n  globalPriority: config.PRIORITY_GLOBAL,\n  globalClearDepth: false,\n\n  globalRenderQueue: false,\n  clearGlobalRenderQueue: () => set(() => ({ globalRenderQueue: false })),\n\n  // true if WebGL initialized without errors\n  isCanvasAvailable: true,\n\n  // true if <VirtualScrollbar> is currently enabled\n  hasSmoothScrollbar: false,\n\n  // map of all components to render on the global canvas\n  canvasChildren: {},\n\n  // add component to canvas\n  renderToCanvas: (key, mesh, props = {}) =>\n    set(({ canvasChildren }) => {\n      // check if already mounted\n      if (Object.getOwnPropertyDescriptor(canvasChildren, key)) {\n        // increase usage count\n        canvasChildren[key].instances += 1\n        canvasChildren[key].props.inactive = false\n        return { canvasChildren }\n      } else {\n        // otherwise mount it\n        const obj = { ...canvasChildren, [key]: { mesh, props, instances: 1 } }\n        return { canvasChildren: obj }\n      }\n    }),\n\n  // pass new props to a canvas component\n  updateCanvas: (key, newProps) =>\n    // @ts-ignore\n    set(({ canvasChildren }) => {\n      if (!canvasChildren[key]) return\n      const {\n        [key]: { mesh, props, instances },\n      } = canvasChildren\n      const obj = {\n        ...canvasChildren,\n        [key]: { mesh, props: { ...props, ...newProps }, instances },\n      }\n      // console.log('updateCanvas', key, { ...props, ...newProps })\n      return { canvasChildren: obj }\n    }),\n\n  // remove component from canvas\n  removeFromCanvas: (key, dispose = true) =>\n    set(({ canvasChildren }) => {\n      // check if remove or reduce instances\n      if (canvasChildren[key]?.instances > 1) {\n        // reduce usage count\n        canvasChildren[key].instances -= 1\n        return { canvasChildren }\n      } else {\n        if (dispose) {\n          // unmount since no longer used\n          const { [key]: _omit, ...obj } = canvasChildren // make a separate copy of the obj and omit\n          return { canvasChildren: obj }\n        } else {\n          // or tell it that it is \"inactive\"\n          canvasChildren[key].instances = 0\n          canvasChildren[key].props.inactive = true\n          return { canvasChildren: { ...canvasChildren } }\n        }\n      }\n    }),\n\n  // Used to ask components to re-calculate their positions after a layout reflow\n  pageReflow: 0,\n  requestReflow: () => {\n    set((state) => {\n      return { pageReflow: state.pageReflow + 1 }\n    })\n  },\n\n  // keep track of scrollbar\n  scroll: {\n    y: 0,\n    x: 0,\n    limit: 0,\n    velocity: 0,\n    progress: 0,\n    direction: 0,\n    scrollDirection: undefined,\n  },\n  scrollTo: (target) => window.scrollTo(0, target),\n  onScroll: () => () => {},\n}))\n\nexport { useCanvasStore }\n","import { useCanvasStore } from '../store'\nimport { ScrollCallback } from './SmoothScrollbar.d'\n\nexport interface Scroll {\n  y: number\n  x: number\n  limit: number\n  velocity: number\n  progress: number\n  direction: number\n  scrollDirection: string\n}\n\ninterface UseScrollbarProps {\n  enabled: boolean\n  scroll: Scroll\n  scrollTo: (target: any) => void\n  onScroll: (cb: ScrollCallback) => () => void\n}\n\n/**\n * Public interface for ScrollRig\n */\nexport const useScrollbar = () => {\n  const hasSmoothScrollbar = useCanvasStore((state) => state.hasSmoothScrollbar)\n  const scroll = useCanvasStore((state) => state.scroll)\n  const scrollTo = useCanvasStore((state) => state.scrollTo)\n  const onScroll = useCanvasStore((state) => state.onScroll)\n\n  return {\n    enabled: hasSmoothScrollbar,\n    scroll,\n    scrollTo,\n    onScroll,\n  } as UseScrollbarProps\n}\n","import { useEffect, useLayoutEffect as vanillaUseLayoutEffect } from 'react'\n\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const useLayoutEffect = isBrowser ? vanillaUseLayoutEffect : useEffect\n","import { useEffect, useRef, useCallback, ReactElement, forwardRef, useImperativeHandle } from 'react'\nimport Lenis from '@studio-freight/lenis'\n\nimport { useLayoutEffect } from '../hooks/useIsomorphicLayoutEffect'\nimport { useCanvasStore } from '../store'\nimport { ISmoothScrollbar, ScrollCallback, ScrollToTarget, ScrollToConfig } from './SmoothScrollbar.d'\n\nconst POINTER_EVENTS_ENABLE_VELOCITY = 1\nconst POINTER_EVENTS_DISABLE_VELOCITY = 1.5\n\nconst SmoothScrollbarImpl = (\n  {\n    children,\n    enabled = true,\n    locked = false,\n    scrollRestoration = 'auto',\n    disablePointerOnScroll = true,\n    horizontal = false,\n    scrollInContainer = false,\n    updateGlobalState = true,\n    onScroll,\n    config = {},\n    invalidate = () => {},\n    addEffect,\n  }: ISmoothScrollbar,\n  ref: any\n) => {\n  const innerRef = useRef<HTMLElement>()\n  const lenis = useRef<Lenis>()\n  const preventPointer = useRef(false)\n  const globalScrollState = useCanvasStore((s) => s.scroll)\n\n  // Expose lenis imperative API\n  useImperativeHandle(ref, () => ({\n    start: () => lenis.current?.start(),\n    stop: () => lenis.current?.stop(),\n    on: (event: string, cb: ScrollCallback) => lenis.current?.on(event, cb),\n    once: (event: string, cb: ScrollCallback) => lenis.current?.once(event, cb),\n    off: (event: string, cb?: ScrollCallback) => lenis.current?.off(event, cb),\n    notify: () => lenis.current?.notify(),\n    scrollTo: (target: ScrollToTarget, props: ScrollToConfig) => lenis.current?.scrollTo(target, props),\n    raf: (time: number) => lenis.current?.raf(time),\n    __lenis: lenis.current,\n  }))\n\n  // disable pointer events while scrolling to avoid slow event handlers\n  const preventPointerEvents = useCallback(\n    (prevent: boolean) => {\n      if (!disablePointerOnScroll) return\n      if (innerRef.current && preventPointer.current !== prevent) {\n        preventPointer.current = prevent\n        innerRef.current.style.pointerEvents = prevent ? 'none' : 'auto'\n      }\n    },\n    [disablePointerOnScroll, innerRef, preventPointer]\n  )\n\n  // apply chosen scroll restoration\n  useLayoutEffect(() => {\n    if ('scrollRestoration' in window.history) {\n      window.history.scrollRestoration = scrollRestoration\n    }\n  }, [])\n\n  // INIT LENIS\n  useLayoutEffect(() => {\n    // Set up scroll containers - allows scrolling without resizing window on iOS/mobile\n    const html = document.documentElement\n    const wrapper = document.body\n    const content = document.body.firstElementChild\n\n    html.classList.toggle('ScrollRig-scrollHtml', scrollInContainer)\n    wrapper.classList.toggle('ScrollRig-scrollWrapper', scrollInContainer)\n\n    if (scrollInContainer) {\n      Object.assign(config, {\n        smoothTouch: true,\n        wrapper,\n        content,\n      })\n    }\n\n    lenis.current = new Lenis({\n      direction: horizontal ? 'horizontal' : 'vertical',\n      ...config,\n    })\n\n    // let r3f drive the frameloop\n    let removeEffect: () => void\n    if (addEffect) {\n      removeEffect = addEffect((time: number) => lenis.current?.raf(time))\n    } else {\n      // manual animation frame\n      // TODO use framer motion / popmotion render loop?\n      let _raf: number\n      function raf(time: number) {\n        lenis.current?.raf(time)\n        _raf = requestAnimationFrame(raf)\n      }\n      _raf = requestAnimationFrame(raf)\n      removeEffect = () => cancelAnimationFrame(_raf)\n    }\n\n    return () => {\n      removeEffect()\n      lenis.current?.destroy()\n    }\n  }, [])\n\n  // BIND TO LENIS SCROLL EVENT\n  useLayoutEffect(() => {\n    lenis.current?.on('scroll', ({ scroll, limit, velocity, direction, progress }: any) => {\n      const y = !horizontal ? scroll : 0\n      const x = horizontal ? scroll : 0\n\n      // update global scroll store\n      if (updateGlobalState) {\n        globalScrollState.y = y\n        globalScrollState.x = x\n        globalScrollState.limit = limit\n        globalScrollState.velocity = velocity\n        globalScrollState.direction = direction\n        globalScrollState.progress = progress\n      }\n\n      if (Math.abs(velocity) > POINTER_EVENTS_DISABLE_VELOCITY) {\n        preventPointerEvents(true)\n      }\n      if (Math.abs(velocity) < POINTER_EVENTS_ENABLE_VELOCITY) {\n        preventPointerEvents(false)\n      }\n\n      onScroll && onScroll({ scroll, limit, velocity, direction, progress })\n\n      invalidate() // demand a R3F frame on scroll\n    })\n\n    // update global state\n    if (updateGlobalState) {\n      globalScrollState.scrollDirection = horizontal ? 'horizontal' : 'vertical'\n\n      // expose global scrollTo function\n      // @ts-ignore\n      useCanvasStore.setState({ scrollTo: lenis.current?.scrollTo })\n\n      // expose global onScroll function to subscribe to scroll events\n      useCanvasStore.setState({\n        onScroll: (cb: ScrollCallback) => {\n          lenis.current?.on('scroll', cb)\n          lenis.current?.notify() // send current scroll to new subscriber\n          return () => lenis.current?.off('scroll', cb)\n        },\n      })\n\n      // Set current scroll position on load in case reloaded further down\n      useCanvasStore.getState().scroll.y = window.scrollY\n      useCanvasStore.getState().scroll.x = window.scrollX\n    }\n\n    // fire our internal scroll callback to update globalState\n    lenis.current?.notify()\n    return () => {\n      lenis.current?.off('scroll')\n    }\n  }, [])\n\n  // Interaction events - invalidate R3F loop and enable pointer events\n  useLayoutEffect(() => {\n    const invalidateOnWheelEvent = () => invalidate()\n    const onPointerInteraction = () => preventPointerEvents(false)\n    window.addEventListener('pointermove', onPointerInteraction)\n    window.addEventListener('pointerdown', onPointerInteraction)\n    window.addEventListener('wheel', invalidateOnWheelEvent)\n    return () => {\n      lenis.current?.off('scroll')\n      window.removeEventListener('pointermove', onPointerInteraction)\n      window.removeEventListener('pointerdown', onPointerInteraction)\n      window.removeEventListener('wheel', invalidateOnWheelEvent)\n    }\n  }, [])\n\n  // Mark as enabled in global state\n  useEffect(() => {\n    if (updateGlobalState) {\n      document.documentElement.classList.toggle('js-smooth-scrollbar-enabled', enabled)\n      document.documentElement.classList.toggle('js-smooth-scrollbar-disabled', !enabled)\n      useCanvasStore.setState({ hasSmoothScrollbar: enabled })\n    }\n  }, [enabled])\n\n  useEffect(() => {\n    locked ? lenis.current?.stop() : lenis.current?.start()\n  }, [locked])\n\n  {\n    /* Use function child so we can spread props\n    - for instance disable pointer events while scrolling */\n  }\n  return children({ ref: innerRef })\n}\n\nexport const SmoothScrollbar = forwardRef<any, ISmoothScrollbar>(SmoothScrollbarImpl)\n","import { useState, useEffect } from 'react'\nimport { ResizeObserver as Polyfill } from '@juggle/resize-observer'\nimport pkg from 'debounce'\n\nconst isBrowser = typeof window !== 'undefined'\nexport interface WindowSize {\n  width: number\n  height: number\n}\n\ntype ConfigProps = {\n  debounce?: number\n}\n\n/*\n * Triggers a resize only if the Canvas DOM element changed dimensions - not on window resize event\n *\n * This is to avoid costly re-renders when the URL bar is scrolled away on mobile\n *\n * Based on: https://usehooks.com/useWindowSize/\n */\n\nexport function useWindowSize({ debounce = 0 }: ConfigProps = {}) {\n  // Initialize state with undefined width/height so server and client renders match\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: isBrowser ? window.innerWidth : Infinity,\n    height: isBrowser ? window.innerHeight : Infinity,\n  })\n\n  useEffect(() => {\n    // check if we can find a canvas - if so, base size on canvas instead of window\n    // since 100vh !== window.innerHeight on mobile\n    const canvasEl = document.getElementById('ScrollRig-canvas')\n\n    // Handler to call on window resize\n    function handleResize() {\n      const width = canvasEl ? canvasEl.clientWidth : window.innerWidth\n      const height = canvasEl ? canvasEl.clientHeight : window.innerHeight\n\n      if (width !== windowSize.width || height !== windowSize.height) {\n        // Set window width/height to state\n        setWindowSize({\n          width,\n          height,\n        })\n      }\n    }\n\n    const debouncedResize = pkg.debounce(handleResize, debounce)\n\n    // Add event listener\n    const ResizeObserver = window.ResizeObserver || Polyfill\n    let observer: ResizeObserver\n    if (canvasEl) {\n      observer = new ResizeObserver(debouncedResize)\n      observer.observe(canvasEl)\n    } else {\n      window.addEventListener('resize', debouncedResize)\n    }\n    // Call handler right away so state gets updated with initial window size\n    handleResize()\n    // Remove event listener on cleanup\n    return () => {\n      window.removeEventListener('resize', debouncedResize)\n      observer?.disconnect()\n    }\n  }, [windowSize, setWindowSize])\n\n  return windowSize\n}\n","// Linear mapping from range <a1, a2> to range <b1, b2>\nexport function mapLinear(x: number, a1: number, a2: number, b1: number, b2: number) {\n  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1)\n}\n","import { useRef, useCallback, useEffect, useMemo, useState, MutableRefObject } from 'react'\nimport { useInView } from 'react-intersection-observer'\nimport { useWindowSize } from './useWindowSize'\nimport vecn from 'vecn'\n\nimport { useLayoutEffect } from '../hooks/useIsomorphicLayoutEffect'\nimport { mapLinear } from '../utils/math'\nimport { useCanvasStore } from '../store'\n\nimport { useScrollbar, Scroll } from '../scrollbar/useScrollbar'\n\nimport type { Rect, Bounds, TrackerOptions, Tracker, ScrollState, UpdateCallback } from './useTracker.d'\n\nfunction updateBounds(bounds: Bounds, rect: Rect, scroll: Scroll, size: any) {\n  bounds.top = rect.top - (scroll.y || 0)\n  bounds.bottom = rect.bottom - (scroll.y || 0)\n  bounds.left = rect.left - (scroll.x || 0)\n  bounds.right = rect.right - (scroll.x || 0)\n  bounds.width = rect.width\n  bounds.height = rect.height\n  // move coordinate system so 0,0 is at center of screen\n  bounds.x = bounds.left + rect.width * 0.5 - size.width * 0.5\n  bounds.y = bounds.top + rect.height * 0.5 - size.height * 0.5\n  bounds.positiveYUpBottom = size.height - bounds.bottom // inverse Y\n}\n\nfunction updatePosition(position: vec3, bounds: Bounds, scaleMultiplier: number) {\n  position.x = bounds.x * scaleMultiplier\n  position.y = -1 * bounds.y * scaleMultiplier\n}\n\n/**\n * Returns the current Scene position of the DOM element\n * based on initial getBoundingClientRect and scroll delta from start\n */\nfunction useTracker(track: MutableRefObject<HTMLElement>, options?: TrackerOptions): Tracker {\n  const size = useWindowSize()\n  const { scroll, onScroll } = useScrollbar()\n  const scaleMultiplier = useCanvasStore((state) => state.scaleMultiplier)\n  const pageReflow = useCanvasStore((state) => state.pageReflow)\n  const debug = useCanvasStore((state) => state.debug)\n\n  // extend defaults with optional options\n  const { rootMargin, threshold, autoUpdate, wrapper } = useMemo(() => {\n    const target = { rootMargin: '0%', threshold: 0, autoUpdate: true } as TrackerOptions\n    const opts = options || {}\n    Object.keys(opts).map((key: string, index) => {\n      if (opts[key] !== undefined) target[key] = opts[key]\n    })\n    return target\n  }, [options])\n\n  // check if element is in viewport\n  const { ref, inView: inViewport } = useInView({ rootMargin, threshold })\n\n  // bind useInView ref to current tracking element\n  useLayoutEffect(() => {\n    ref(track.current)\n  }, [track])\n\n  // Using state so it's reactive\n  const [scale, setScale] = useState<vec3>(vecn.vec3(0, 0, 0))\n\n  // Using ref because\n  const scrollState: ScrollState = useRef({\n    inViewport: false,\n    progress: -1,\n    visibility: -1,\n    viewport: -1,\n  }).current\n\n  // DOM rect (initial position in pixels offset by scroll value on page load)\n  // Using ref so we can calculate bounds & position without a re-render\n  const rect = useRef({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0,\n  }).current\n\n  // expose internal ref as a reactive state as well\n  const [reactiveRect, setReactiveRect] = useState<Rect>(rect)\n\n  // bounding rect in pixels - updated by scroll\n  const bounds = useRef({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n    positiveYUpBottom: 0,\n  }).current\n\n  // position in viewport units - updated by scroll\n  const position = useRef(vecn.vec3(0, 0, 0)).current\n\n  // Calculate bounding Rect as soon as it's available\n  useLayoutEffect(() => {\n    const _rect = track.current?.getBoundingClientRect()\n    if (!_rect) return\n    const initialY = wrapper ? (wrapper as HTMLElement).scrollTop : window.scrollY\n    const initialX = wrapper ? (wrapper as HTMLElement).scrollLeft : window.scrollX\n    rect.top = _rect.top + initialY\n    rect.bottom = _rect.bottom + initialY\n    rect.left = _rect.left + initialX\n    rect.right = _rect.right + initialX\n    rect.width = _rect.width\n    rect.height = _rect.height\n    setReactiveRect({ ...rect })\n    setScale(vecn.vec3(rect?.width * scaleMultiplier, rect?.height * scaleMultiplier, 1))\n    debug &&\n      console.log(\n        'useTracker.getBoundingClientRect:',\n        rect,\n        'intialScroll:',\n        { initialY, initialX },\n        'size:',\n        size,\n        'pageReflow:',\n        pageReflow\n      )\n  }, [track, size, pageReflow, scaleMultiplier, debug])\n\n  const update = useCallback(\n    ({ onlyUpdateInViewport = false, scroll: overrideScroll }: UpdateCallback = {}) => {\n      if (!track.current || (onlyUpdateInViewport && !scrollState.inViewport)) {\n        return\n      }\n\n      const _scroll = overrideScroll || scroll\n\n      updateBounds(bounds, rect, _scroll, size)\n      updatePosition(position, bounds, scaleMultiplier)\n\n      // scrollState setup based on scroll direction\n      const isHorizontal = _scroll.scrollDirection === 'horizontal'\n      const sizeProp = isHorizontal ? 'width' : 'height'\n      const startProp = isHorizontal ? 'left' : 'top'\n\n      // calculate progress of passing through viewport (0 = just entered, 1 = just exited)\n      const pxInside = size[sizeProp] - bounds[startProp]\n      scrollState.progress = mapLinear(pxInside, 0, size[sizeProp] + bounds[sizeProp], 0, 1) // percent of total visible distance\n      scrollState.visibility = mapLinear(pxInside, 0, bounds[sizeProp], 0, 1) // percent of item height in view\n      scrollState.viewport = mapLinear(pxInside, 0, size[sizeProp], 0, 1) // percent of window height scrolled since visible\n    },\n    [track, size, scaleMultiplier, scroll]\n  )\n\n  // update scrollState in viewport\n  useLayoutEffect(() => {\n    scrollState.inViewport = inViewport\n    // update once more in case it went out of view\n    update({ onlyUpdateInViewport: false })\n    debug && console.log('useTracker.inViewport:', inViewport, 'update()')\n  }, [inViewport])\n\n  // re-run if the callback updated\n  useLayoutEffect(() => {\n    update({ onlyUpdateInViewport: false })\n    debug && console.log('useTracker.update on resize/reflow')\n  }, [update, pageReflow])\n\n  // auto-update on scroll\n  useEffect(() => {\n    if (autoUpdate) return onScroll((_scroll) => update({ onlyUpdateInViewport: true }))\n  }, [autoUpdate, update, onScroll])\n\n  return {\n    rect: reactiveRect, // Dom rect - doesn't change on scroll - not - reactive\n    bounds, // scrolled bounding rect in pixels - not reactive\n    scale, // reactive scene scale - includes z-axis so it can be spread onto mesh directly\n    position, // scrolled element position in viewport units - not reactive\n    scrollState, // scroll progress stats - not reactive\n    inViewport, // reactive prop for when inside viewport\n    update, // optional manual update\n  }\n}\n\nexport { useTracker }\n"],"names":["useCanvasStore","create","set","debug","scaleMultiplier","globalRender","globalPriority","globalClearDepth","globalRenderQueue","clearGlobalRenderQueue","isCanvasAvailable","hasSmoothScrollbar","canvasChildren","renderToCanvas","key","mesh","props","Object","getOwnPropertyDescriptor","instances","inactive","_extends","updateCanvas","newProps","removeFromCanvas","dispose","_canvasChildren$key","_objectWithoutPropertiesLoose","map","_toPropertyKey","pageReflow","requestReflow","state","scroll","y","x","limit","velocity","progress","direction","scrollDirection","undefined","scrollTo","target","window","onScroll","useScrollbar","enabled","useLayoutEffect","vanillaUseLayoutEffect","useEffect","SmoothScrollbar","forwardRef","SmoothScrollbarImpl","children","locked","scrollRestoration","disablePointerOnScroll","horizontal","scrollInContainer","updateGlobalState","config","invalidate","addEffect","ref","innerRef","useRef","lenis","preventPointer","globalScrollState","s","useImperativeHandle","start","_lenis$current","current","stop","_lenis$current2","on","event","cb","_lenis$current3","once","_lenis$current4","off","_lenis$current5","notify","_lenis$current6","_lenis$current7","raf","time","_lenis$current8","__lenis","preventPointerEvents","useCallback","prevent","style","pointerEvents","history","html","document","documentElement","wrapper","body","content","firstElementChild","removeEffect","classList","toggle","assign","smoothTouch","Lenis","_lenis$current9","_raf","requestAnimationFrame","_lenis$current10","cancelAnimationFrame","_lenis$current11","destroy","_lenis$current12","_lenis$current17","_lenis$current13","Math","abs","setState","_lenis$current14","_lenis$current15","_lenis$current16","getState","scrollY","scrollX","_lenis$current18","invalidateOnWheelEvent","onPointerInteraction","addEventListener","_lenis$current19","removeEventListener","_lenis$current20","_lenis$current21","isBrowser","mapLinear","a1","a2","b1","b2","useTracker","track","options","size","debounce","windowSize","setWindowSize","useState","width","innerWidth","Infinity","height","innerHeight","canvasEl","getElementById","handleResize","clientWidth","clientHeight","debouncedResize","pkg","ResizeObserver","Polyfill","observer","observe","_observer","disconnect","useWindowSize","rootMargin","threshold","autoUpdate","useMemo","opts","keys","index","inView","inViewport","useInView","scale","setScale","vecn","vec3","scrollState","visibility","viewport","rect","top","bottom","left","right","reactiveRect","setReactiveRect","bounds","positiveYUpBottom","position","_track$current","_rect","getBoundingClientRect","initialY","scrollTop","initialX","scrollLeft","console","log","update","onlyUpdateInViewport","overrideScroll","_scroll","updateBounds","updatePosition","isHorizontal","sizeProp","pxInside"],"mappings":"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"}