{"version":3,"file":"scrollbar.modern.js","sources":["../src/config.ts","../src/store.ts","../src/scrollbar/useScrollbar.ts","../src/hooks/useIsomorphicLayoutEffect.ts","../src/scrollbar/LenisScrollbar.tsx","../src/scrollbar/SmoothScrollbar.tsx","../src/hooks/useWindowSize.ts","../src/utils/math.ts","../src/hooks/useTracker.ts"],"sourcesContent":["// Global config\n\nimport { WebGLRenderer } from 'three'\n\ntype PreloadCallback = (gl: WebGLRenderer) => void\n\nexport const config = {\n  // Execution order for useFrames (highest = last render)\n  PRIORITY_PRELOAD: 0,\n  PRIORITY_SCISSORS: 1,\n  PRIORITY_VIEWPORTS: 1,\n  PRIORITY_GLOBAL: 1000,\n\n  DEFAULT_SCALE_MULTIPLIER: 1,\n\n  // Global rendering props\n  preloadQueue: [] as PreloadCallback[],\n}\n","import create from 'zustand'\nimport { config } from './config'\n\nimport { LenisScrollCallback } from './scrollbar/LenisScrollbar'\n\ninterface ScrollRigStore {\n  debug: boolean\n  scaleMultiplier: number\n  globalRender: boolean\n  globalPriority: number\n  globalAutoClear: boolean\n  globalClearDepth: boolean\n  globalRenderQueue: false | any[]\n  clearGlobalRenderQueue: () => void\n  isCanvasAvailable: boolean\n  hasSmoothScrollbar: boolean\n  canvasChildren: Record<string, any | undefined>\n  updateCanvas: (key: string, newProps: any) => void\n  renderToCanvas: (key: string, mesh: any, props: any) => void\n  removeFromCanvas: (key: string, dispose: boolean) => void\n  pageReflow: number\n  requestReflow: () => void\n  scroll: {\n    y: number\n    x: number\n    limit: number\n    velocity: number\n    progress: number\n    direction: string\n  }\n  scrollTo: (target: any) => void\n  onScroll: (cb: LenisScrollCallback) => () => void\n}\n\nconst useCanvasStore = create<ScrollRigStore>((set) => ({\n  // //////////////////////////////////////////////////////////////////////////\n  // GLOBAL ScrollRig STATE\n  // //////////////////////////////////////////////////////////////////////////\n  debug: false,\n  scaleMultiplier: config.DEFAULT_SCALE_MULTIPLIER,\n\n  globalRender: true,\n  globalPriority: config.PRIORITY_GLOBAL,\n  globalAutoClear: false,\n  globalClearDepth: true,\n\n  globalRenderQueue: false,\n  clearGlobalRenderQueue: () => set(() => ({ globalRenderQueue: false })),\n\n  // true if WebGL initialized without errors\n  isCanvasAvailable: true,\n\n  // true if <VirtualScrollbar> is currently enabled\n  hasSmoothScrollbar: false,\n\n  // map of all components to render on the global canvas\n  canvasChildren: {},\n\n  // add component to canvas\n  renderToCanvas: (key, mesh, props = {}) =>\n    set(({ canvasChildren }) => {\n      // check if already mounted\n      if (Object.getOwnPropertyDescriptor(canvasChildren, key)) {\n        // increase usage count\n        canvasChildren[key].instances += 1\n        canvasChildren[key].props.inactive = false\n        return { canvasChildren }\n      } else {\n        // otherwise mount it\n        const obj = { ...canvasChildren, [key]: { mesh, props, instances: 1 } }\n        return { canvasChildren: obj }\n      }\n    }),\n\n  // pass new props to a canvas component\n  updateCanvas: (key, newProps) =>\n    // @ts-ignore\n    set(({ canvasChildren }) => {\n      if (!canvasChildren[key]) return\n      const {\n        [key]: { mesh, props, instances },\n      } = canvasChildren\n      const obj = {\n        ...canvasChildren,\n        [key]: { mesh, props: { ...props, ...newProps }, instances },\n      }\n      // console.log('updateCanvas', key, { ...props, ...newProps })\n      return { canvasChildren: obj }\n    }),\n\n  // remove component from canvas\n  removeFromCanvas: (key, dispose = true) =>\n    set(({ canvasChildren }) => {\n      // check if remove or reduce instances\n      if (canvasChildren[key]?.instances > 1) {\n        // reduce usage count\n        canvasChildren[key].instances -= 1\n        return { canvasChildren }\n      } else {\n        if (dispose) {\n          // unmount since no longer used\n          const { [key]: _omit, ...obj } = canvasChildren // make a separate copy of the obj and omit\n          return { canvasChildren: obj }\n        } else {\n          // or tell it that it is \"inactive\"\n          canvasChildren[key].instances = 0\n          canvasChildren[key].props.inactive = true\n          return { canvasChildren: { ...canvasChildren } }\n        }\n      }\n    }),\n\n  // Used to ask components to re-calculate their positions after a layout reflow\n  pageReflow: 0,\n  requestReflow: () => {\n    set((state) => {\n      return { pageReflow: state.pageReflow + 1 }\n    })\n  },\n\n  // keep track of scrollbar\n  scroll: {\n    y: 0,\n    x: 0,\n    limit: 0,\n    velocity: 0,\n    progress: 0,\n    direction: '',\n  },\n  scrollTo: (target) => window.scrollTo(0, target),\n  onScroll: () => () => {},\n}))\n\nexport { useCanvasStore }\n","import { useCanvasStore } from '../store'\nimport { LenisScrollCallback } from './LenisScrollbar'\n\nexport interface Scroll {\n  y: number\n  x: number\n  limit: number\n  velocity: number\n  progress: number\n  direction: string\n}\n\ninterface UseScrollbarProps {\n  enabled: boolean\n  scroll: Scroll\n  scrollTo: (target: any) => void\n  onScroll: (cb: LenisScrollCallback) => () => void\n}\n\n/**\n * Public interface for ScrollRig\n */\nexport const useScrollbar = () => {\n  const hasSmoothScrollbar = useCanvasStore((state) => state.hasSmoothScrollbar)\n  const scroll = useCanvasStore((state) => state.scroll)\n  const scrollTo = useCanvasStore((state) => state.scrollTo)\n  const onScroll = useCanvasStore((state) => state.onScroll)\n\n  return {\n    enabled: hasSmoothScrollbar,\n    scroll,\n    scrollTo,\n    onScroll,\n  } as UseScrollbarProps\n}\n","import { useEffect, useLayoutEffect as vanillaUseLayoutEffect } from 'react'\n\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const useLayoutEffect = isBrowser ? vanillaUseLayoutEffect : useEffect\n","import React, { useRef, useEffect, forwardRef, useImperativeHandle, ReactElement } from 'react'\n\n// @ts-ignore\n// eslint-disable-next-line import/no-unresolved\nimport Lenis from '@studio-freight/lenis'\n\nexport type LenisScrollCallback = (props: {\n  scroll: number\n  limit: number\n  velocity: number\n  direction: string\n  progress: number\n}) => void\n\ntype LenisScrollToTarget = number | HTMLElement | string\ntype LenisScrollToConfig = { offset: number; immediate: boolean; duration: number; easing: (t: number) => number }\ntype LenisScrollTo = (target: LenisScrollToTarget, props: LenisScrollToConfig) => void\n\ntype LenisScrollbarProps = {\n  children: (props: any) => ReactElement\n  duration?: number\n  easing?: (t: number) => number\n  smooth?: boolean\n  direction?: string\n  config?: any\n}\n\nexport interface ILenisScrollbar {\n  stop: () => void\n  start: () => void\n  on: (event: string, cb: LenisScrollCallback) => void\n  once: (event: string, cb: LenisScrollCallback) => void\n  off: (event: string, cb: LenisScrollCallback) => void\n  scrollTo: LenisScrollTo\n  raf: (time: number) => void\n}\n\nconst EASE_EXP_OUT = (t: number) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t)) // https://easings.net/\n\nexport function LenisScrollbar(\n  {\n    children,\n    duration = 1,\n    easing = EASE_EXP_OUT,\n    smooth = true,\n    direction = 'vertical',\n    config,\n    ...props\n  }: LenisScrollbarProps,\n  ref: any\n) {\n  const lenisImpl = useRef<ILenisScrollbar>()\n\n  // Expose lenis imperative API\n  useImperativeHandle(ref, () => ({\n    start: () => lenisImpl.current?.start(),\n    stop: () => lenisImpl.current?.stop(),\n    on: (event: string, cb: LenisScrollCallback) => lenisImpl.current?.on(event, cb),\n    once: (event: string, cb: LenisScrollCallback) => lenisImpl.current?.once(event, cb),\n    off: (event: string, cb: LenisScrollCallback) => lenisImpl.current?.off(event, cb),\n    scrollTo: (target: LenisScrollToTarget, props: LenisScrollToConfig) => lenisImpl.current?.scrollTo(target, props),\n    raf: (time: number) => lenisImpl.current?.raf(time),\n  }))\n\n  useEffect(\n    function initLenis() {\n      // @ts-ignore\n      const lenis = (lenisImpl.current = new Lenis({\n        duration,\n        easing,\n        smooth,\n        direction,\n        ...config,\n      }))\n\n      // cleanup on unmount\n      return () => {\n        lenis.destroy()\n      }\n    },\n    [duration, easing, smooth, direction]\n  )\n\n  // Support a render function as child\n  return children && children(props)\n}\n\nexport default forwardRef(LenisScrollbar)\n","import React, { useEffect, useRef, useCallback, ReactElement } from 'react'\nimport { addEffect, invalidate } from '@react-three/fiber'\nimport pkg from 'debounce'\n\nimport { useLayoutEffect } from '../hooks/useIsomorphicLayoutEffect'\nimport { useCanvasStore } from '../store'\n\nimport LenisScrollbar, { ILenisScrollbar, LenisScrollCallback } from './LenisScrollbar'\ninterface ISmoothScrobbar {\n  children: (props: any) => ReactElement\n  scrollRestoration?: ScrollRestoration\n  enabled?: boolean\n  locked?: boolean\n  disablePointerOnScroll?: boolean\n  config?: object\n  horizontal?: boolean\n}\n\nexport const SmoothScrollbar = ({\n  children,\n  enabled = true,\n  locked = false,\n  scrollRestoration = 'auto',\n  disablePointerOnScroll = true,\n  horizontal = false,\n  config,\n}: ISmoothScrobbar) => {\n  const ref = useRef<HTMLElement>()\n  const lenis = useRef<ILenisScrollbar>()\n  const preventPointer = useRef(false)\n  const globalScrollState = useCanvasStore((state) => state.scroll)\n\n  // set initial scroll direction\n  // need to be updated before children render\n  globalScrollState.direction = horizontal ? 'horizontal' : 'vertical'\n\n  // disable pointer events while scrolling to avoid slow event handlers\n  const preventPointerEvents = (prevent: boolean) => {\n    if (!disablePointerOnScroll) return\n    if (ref.current && preventPointer.current !== prevent) {\n      preventPointer.current = prevent\n      ref.current.style.pointerEvents = prevent ? 'none' : 'auto'\n    }\n  }\n\n  // reset pointer events when moving mouse\n  const onMouseMove = useCallback(() => {\n    preventPointerEvents(false)\n  }, [])\n\n  // function to bind to scroll event\n  // return function that will unbind same callback\n  const onScroll = useCallback((cb: LenisScrollCallback) => {\n    lenis.current?.on('scroll', cb)\n    return () => lenis.current?.off('scroll', cb)\n  }, [])\n\n  // apply chosen scroll restoration\n  useLayoutEffect(() => {\n    if ('scrollRestoration' in window.history) {\n      window.history.scrollRestoration = scrollRestoration\n    }\n  }, [])\n\n  useEffect(() => {\n    // let r3f drive the frameloop\n    const removeEffect = addEffect((time) => lenis.current?.raf(time))\n\n    // update global scroll store\n    lenis.current?.on('scroll', ({ scroll, limit, velocity, direction, progress }) => {\n      globalScrollState.y = direction === 'vertical' ? scroll : 0\n      globalScrollState.x = direction === 'horizontal' ? scroll : 0\n      globalScrollState.limit = limit\n      globalScrollState.velocity = velocity\n      globalScrollState.direction = direction\n      globalScrollState.progress = progress\n\n      // disable pointer logic\n      const disablePointer = pkg.debounce(() => preventPointerEvents(true), 100, true)\n      if (Math.abs(velocity) > 1.4) {\n        disablePointer()\n      } else {\n        preventPointerEvents(false)\n      }\n\n      invalidate()\n    })\n\n    // expose global scrollTo function\n    // @ts-ignore\n    useCanvasStore.setState({ scrollTo: lenis.current?.scrollTo })\n\n    // expose global onScroll function to subscribe to scroll events\n    // @ts-ignore\n    useCanvasStore.setState({ onScroll })\n\n    // Set current scroll position on load in case reloaded further down\n    useCanvasStore.getState().scroll.y = window.scrollY\n    useCanvasStore.getState().scroll.x = window.scrollX\n\n    // Set active\n    document.documentElement.classList.toggle('js-smooth-scrollbar-enabled', enabled)\n    document.documentElement.classList.toggle('js-smooth-scrollbar-disabled', !enabled)\n    useCanvasStore.setState({ hasSmoothScrollbar: enabled })\n\n    // make sure R3F loop is invalidated when scrolling\n    const invalidateOnWheelEvent = () => invalidate()\n\n    window.addEventListener('pointermove', onMouseMove)\n    window.addEventListener('wheel', invalidateOnWheelEvent)\n    return () => {\n      removeEffect()\n      window.removeEventListener('pointermove', onMouseMove)\n      window.removeEventListener('wheel', invalidateOnWheelEvent)\n    }\n  }, [enabled])\n\n  useEffect(() => {\n    locked ? lenis.current?.stop() : lenis.current?.start()\n  }, [locked])\n\n  return (\n    <LenisScrollbar ref={lenis} smooth={enabled} direction={horizontal ? 'horizontal' : 'vertical'} config={config}>\n      {/* Use function child so we can spread props\n        - for instance disable pointer events while scrolling */}\n      {(bind: any) => children({ ...bind, ref })}\n    </LenisScrollbar>\n  )\n}\n","import { useState, useEffect } from 'react'\n\nconst isBrowser = typeof window !== 'undefined'\n\n// https://usehooks.com/useWindowSize/\n\nexport interface WindowSize {\n  width: number\n  height: number\n}\n\nexport function useWindowSize() {\n  // Initialize state with undefined width/height so server and client renders match\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: isBrowser ? window.innerWidth : Infinity,\n    height: isBrowser ? window.innerHeight : Infinity,\n  })\n  useEffect(() => {\n    // Handler to call on window resize\n    function handleResize() {\n      // Set window width/height to state\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      })\n    }\n    // Add event listener\n    window.addEventListener('resize', handleResize)\n    // Call handler right away so state gets updated with initial window size\n    handleResize()\n    // Remove event listener on cleanup\n    return () => window.removeEventListener('resize', handleResize)\n  }, []) // Empty array ensures that effect is only run on mount\n\n  return windowSize\n}\n","// Linear mapping from range <a1, a2> to range <b1, b2>\nexport function mapLinear(x: number, a1: number, a2: number, b1: number, b2: number) {\n  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1)\n}\n","import { useRef, useCallback, useEffect, useState, MutableRefObject } from 'react'\nimport { useInView } from 'react-intersection-observer'\nimport { useWindowSize } from './useWindowSize'\nimport vecn from 'vecn'\n\nimport { useLayoutEffect } from '../hooks/useIsomorphicLayoutEffect'\nimport { mapLinear } from '../utils/math'\nimport { useCanvasStore } from '../store'\nimport { useScrollbar, Scroll } from '../scrollbar/useScrollbar'\n\nimport type { Rect, Bounds, TrackerOptions, Tracker, ScrollState } from './useTracker.d'\n\nfunction updateBounds(bounds: Bounds, rect: Rect, scroll: Scroll, size: any) {\n  bounds.top = rect.top - scroll.y\n  bounds.bottom = rect.bottom - scroll.y\n  bounds.left = rect.left - scroll.x\n  bounds.right = rect.right - scroll.x\n  bounds.width = rect.width\n  bounds.height = rect.height\n  // move coordinate system so 0,0 is at center of screen\n  bounds.x = bounds.left + rect.width * 0.5 - size.width * 0.5\n  bounds.y = bounds.top + rect.height * 0.5 - size.height * 0.5\n  bounds.positiveYUpBottom = size.height - bounds.bottom // inverse Y\n}\n\nfunction updatePosition(position: vec3, bounds: Bounds, scaleMultiplier: number) {\n  position.x = bounds.x * scaleMultiplier\n  position.y = -1 * bounds.y * scaleMultiplier\n}\n\nconst defaultArgs = { rootMargin: '50%', threshold: 0, autoUpdate: true }\n\n/**\n * Returns the current Scene position of the DOM element\n * based on initial getBoundingClientRect and scroll delta from start\n */\nfunction useTracker(track: MutableRefObject<HTMLElement>, options?: TrackerOptions): Tracker {\n  const size = useWindowSize()\n  const { scroll, onScroll } = useScrollbar()\n  const scaleMultiplier = useCanvasStore((state) => state.scaleMultiplier)\n  const pageReflow = useCanvasStore((state) => state.pageReflow)\n\n  const { rootMargin, threshold, autoUpdate } = { ...defaultArgs, ...options }\n\n  // check if element is in viewport\n  const { ref, inView: inViewport } = useInView({ rootMargin, threshold })\n\n  // bind useInView ref to current tracking element\n  useLayoutEffect(() => {\n    ref(track.current)\n  }, [track])\n\n  // Using state so it's reactive\n  const [scale, setScale] = useState<vec3>()\n\n  // Using ref because\n  const scrollState: ScrollState = useRef({\n    inViewport: false,\n    progress: -1,\n    visibility: -1,\n    viewport: -1,\n  }).current\n\n  // DOM rect (initial position in pixels offset by scroll value on page load)\n  // Using ref so we can calculate bounds & position without a re-render\n  const rect = useRef({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n  }).current\n\n  // expose internal ref as a reactive state as well\n  const [reactiveRect, setReactiveRect] = useState<Rect>(rect)\n\n  // bounding rect in pixels - updated by scroll\n  const bounds = useRef({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n    positiveYUpBottom: 0,\n  }).current\n\n  // position in viewport units - updated by scroll\n  const position = useRef(vecn.vec3(0, 0, 0)).current\n\n  // Calculate bounding Rect as soon as it's available\n  useLayoutEffect(() => {\n    const _rect = track.current?.getBoundingClientRect()\n    rect.top = _rect.top + window.scrollY\n    rect.bottom = _rect.bottom + window.scrollY\n    rect.left = _rect.left + window.scrollX\n    rect.right = _rect.right + window.scrollX\n    rect.width = _rect.width\n    rect.height = _rect.height\n    rect.x = rect.left + _rect.width * 0.5\n    rect.y = rect.top + _rect.height * 0.5\n    setReactiveRect({ ...rect })\n    setScale(vecn.vec3(rect?.width * scaleMultiplier, rect?.height * scaleMultiplier, 1))\n  }, [track, size, pageReflow, scaleMultiplier])\n\n  const update = useCallback(\n    ({ onlyUpdateInViewport = true } = {}) => {\n      if (!track.current || (onlyUpdateInViewport && !scrollState.inViewport)) {\n        return\n      }\n\n      updateBounds(bounds, rect, scroll, size)\n      updatePosition(position, bounds, scaleMultiplier)\n\n      // scrollState setup based on scroll direction\n      const isHorizontal = scroll.direction === 'horizontal'\n      const sizeProp = isHorizontal ? 'width' : 'height'\n      const startProp = isHorizontal ? 'left' : 'top'\n\n      // calculate progress of passing through viewport (0 = just entered, 1 = just exited)\n      const pxInside = size[sizeProp] - bounds[startProp]\n      scrollState.progress = mapLinear(pxInside, 0, size[sizeProp] + bounds[sizeProp], 0, 1) // percent of total visible distance\n      scrollState.visibility = mapLinear(pxInside, 0, bounds[sizeProp], 0, 1) // percent of item height in view\n      scrollState.viewport = mapLinear(pxInside, 0, size[sizeProp], 0, 1) // percent of window height scrolled since visible\n    },\n    [track, size, scaleMultiplier, scroll]\n  )\n\n  // update scrollState in viewport\n  useLayoutEffect(() => {\n    scrollState.inViewport = inViewport\n    // update once more in case it went out of view\n    update({ onlyUpdateInViewport: false })\n  }, [inViewport])\n\n  // re-run if the callback updated\n  useLayoutEffect(() => {\n    update({ onlyUpdateInViewport: false })\n  }, [update])\n\n  // auto-update on scroll\n  useEffect(() => {\n    if (autoUpdate) return onScroll((_scroll) => update())\n  }, [autoUpdate, update, onScroll])\n\n  return {\n    rect: reactiveRect, // Dom rect - doesn't change on scroll - not - reactive\n    bounds, // scrolled bounding rect in pixels - not reactive\n    scale, // reactive scene scale - includes z-axis so it can be spread onto mesh directly\n    position, // scrolled element position in viewport units - not reactive\n    scrollState, // scroll progress stats - not reactive\n    inViewport, // reactive prop for when inside viewport\n    update: () => update({ onlyUpdateInViewport: false }), // optional manual update\n  }\n}\n\nexport { useTracker }\n"],"names":["create","set","debug","scaleMultiplier","globalRender","globalPriority","globalAutoClear","globalClearDepth","globalRenderQueue","clearGlobalRenderQueue","isCanvasAvailable","hasSmoothScrollbar","canvasChildren","renderToCanvas","key","mesh","props","Object","getOwnPropertyDescriptor","instances","inactive","updateCanvas","newProps","_extends","removeFromCanvas","dispose","_canvasChildren$key","map","_toPropertyKey","pageReflow","requestReflow","state","scroll","y","x","limit","velocity","progress","direction","scrollTo","target","window","onScroll","useScrollbar","enabled","useCanvasStore","useLayoutEffect","vanillaUseLayoutEffect","useEffect","_excluded","EASE_EXP_OUT","t","Math","pow","forwardRef","_ref","ref","children","duration","easing","smooth","config","_objectWithoutPropertiesLoose","lenisImpl","useRef","useImperativeHandle","start","current","_lenisImpl$current","stop","_lenisImpl$current2","on","event","cb","_lenisImpl$current3","once","_lenisImpl$current4","off","_lenisImpl$current5","_lenisImpl$current6","raf","time","_lenisImpl$current7","lenis","Lenis","destroy","SmoothScrollbar","locked","scrollRestoration","disablePointerOnScroll","horizontal","preventPointer","globalScrollState","preventPointerEvents","prevent","style","pointerEvents","onMouseMove","useCallback","_lenis$current","_lenis$current2","history","_lenis$current4","_lenis$current5","addEffect","_lenis$current3","disablePointer","pkg","debounce","abs","invalidate","setState","getState","scrollY","scrollX","document","documentElement","classList","toggle","invalidateOnWheelEvent","addEventListener","removeEffect","removeEventListener","_lenis$current6","_lenis$current7","React","LenisScrollbar","bind","isBrowser","mapLinear","a1","a2","b1","b2","defaultArgs","rootMargin","threshold","autoUpdate","track","options","size","windowSize","setWindowSize","useState","width","innerWidth","Infinity","height","innerHeight","handleResize","useWindowSize","inView","inViewport","useInView","scale","setScale","scrollState","visibility","viewport","rect","top","bottom","left","right","reactiveRect","setReactiveRect","positiveYUpBottom","position","vecn","vec3","_track$current","_rect","getBoundingClientRect","update","onlyUpdateInViewport","bounds","updateBounds","updatePosition","isHorizontal","sizeProp","pxInside","_scroll"],"mappings":"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"}